import { HttpContext } from '@adonisjs/core/http'
import { storeLoginValidator, usernameValidator } from '#validators/auth_validator'
import router from '@adonisjs/core/services/router'
import User from '#models/user'
import mail from '@adonisjs/mail/services/main'
import env from '#start/env'
import { randomUUID } from 'node:crypto'
import {
  badRequestApiResponse,
  notFoundApiResponse,
  successApiResponse,
  tooManyRequestsApiResponse,
  unauthorizedApiResponse,
  validationErrorApiResponse,
} from '#config/openapi'
import { ApiBody, ApiOperation, ApiParam, ApiQuery, ApiTags } from '@foadonis/openapi/decorators'
import { UserLoginDto, UserTokenDto } from '#dtos/user'
import { roleAbilities } from '../enum/user_enum.js'

@ApiTags('Auth')
@validationErrorApiResponse()
@tooManyRequestsApiResponse()
export default class AuthController {
  @ApiOperation({
    summary: 'Send magic link',
    description: 'Sends an email to the user with a link to log in',
    operationId: 'login',
  })
  @notFoundApiResponse()
  @ApiBody({ type: () => storeLoginValidator })
  @successApiResponse({
    schema: {
      type: 'object',
      properties: {
        message: {
          type: 'string',
          example: 'Email sent successfully',
        },
      },
    },
    status: 200,
  })
  async store({ request, response }: HttpContext) {
    await storeLoginValidator.validate(request.all())

    const { email, username } = request.all()

    const user = await User.query().where('email', email).whereNull('deleted_at').first()
    if (!user && !username) {
      return response.notFound({
        message: 'You must provide a username to create a new user',
      })
    }

    const url = router
      .builder()
      .prefixUrl(env.get('APP_URL'))
      .params({ email: email })
      .qs({ uuid: randomUUID(), ...(username ? { username: username } : {}) })
      .makeSigned('/auth/login', { expiresIn: '5m', purpose: 'login' })

    await mail.send((message) => {
      message
        .to(email)
        .subject('Login to AudiobookDB')
        .header('X-PM-Message-Stream', 'outbound')
        .htmlView('email/login_email', { login_url: url })
    })

    return {
      message: 'Email sent successfully',
    }
  }

  @ApiOperation({
    summary: 'Confirm login',
    description:
      'This is an internal endpoint and can currently not be used as the link that is generated by the magic link only can be sent to the offical domain',
    operationId: 'confirmLogin',
  })
  @notFoundApiResponse()
  @successApiResponse({
    type: UserLoginDto,
    status: 200,
  })
  @ApiQuery({
    name: 'uuid',
    description: 'The UUID of the login. Is generated by the magic link',
    required: true,
    schema: { type: 'string', example: '123e4567-e89b-12d3-a456-426614174000' },
  })
  @ApiParam({
    name: 'email',
    description: 'The email of the user to log in',
    required: true,
    schema: { type: 'string', example: 'test@example.com' },
  })
  async create({ request, response }: HttpContext) {
    if (request.hasValidSignature('login')) {
      const email = request.param('email')
      const { uuid, username } = request.qs()

      let user = await User.query().where('email', email).whereNull('deleted_at').first()

      if (username) {
        let existingUser = await User.query()
          .where('username', username)
          .whereNull('deleted_at')
          .first()
        if (existingUser && email !== existingUser.email) {
          return response.badRequest({
            message: 'Username is already taken',
          })
        }
      }

      if (!user) {
        if (!username) {
          return response.badRequest({
            message: 'Username is required for creating a new user',
          })
        }
        user = new User()
        user.email = email
        user.username = username

        await user.save()
      }

      const tokens = await User.accessTokens.all(user)

      if (tokens.find((token) => token.name === uuid)) {
        return response.badRequest('Token already exists')
      }

      return new UserLoginDto(
        user,
        // @ts-ignore
        await User.accessTokens.create(user, roleAbilities[user.role], {
          name: uuid,
        })
      )
    } else {
      return response.badRequest('Expired or invalid token')
    }
  }

  @ApiOperation({
    summary: 'Logout',
    description: 'Logs out the user and deletes the access token',
    operationId: 'logout',
  })
  @unauthorizedApiResponse()
  @successApiResponse({
    schema: {
      type: 'object',
      properties: {
        message: {
          type: 'string',
          example: 'Logged out successfully',
        },
      },
    },
    status: 200,
  })
  async logout({ auth }: HttpContext) {
    const user = auth.user
    if (!user) {
      throw new Error('Unauthorized')
    }

    await User.accessTokens.delete(user, user.currentAccessToken.identifier)

    return {
      message: 'Logged out successfully',
    }
  }

  @ApiOperation({
    summary: 'Generate API key',
    description: 'Generates a new API key for the user',
    operationId: 'generateApiKey',
  })
  @unauthorizedApiResponse()
  @successApiResponse({
    type: UserTokenDto,
    status: 200,
  })
  async apiKey({ auth }: HttpContext) {
    const user = auth.user
    if (!user) {
      throw new Error('Unauthorized')
    }

    return await User.apiTokens.create(user, user.currentAccessToken.abilities, {
      name: randomUUID(),
      expiresIn: '1y',
    })
  }

  @ApiOperation({
    summary: 'Check if username is free',
    description: 'Checks if the username is free',
    operationId: 'checkFreeUsername',
  })
  @badRequestApiResponse()
  @successApiResponse({
    schema: {
      type: 'object',
      properties: {
        message: {
          type: 'string',
          example: 'Username is available',
        },
      },
    },
    status: 200,
  })
  @ApiParam({
    name: 'username',
    description: 'The username to check',
    required: true,
    schema: { type: 'string', example: 'john_doe' },
  })
  async checkFreeUsername({ request, response }: HttpContext) {
    await usernameValidator.validate(request.params())
    const username = request.param('username')

    const user = await User.query().where('username', username).whereNull('deleted_at').first()
    if (user) {
      return response.badRequest({
        message: 'Username is already taken',
      })
    }

    return response.ok({
      message: 'Username is available',
    })
  }
}
